# 인덱스 개념과 작동원리  
B-TREE 인덱스는 트리로 만들어져 있음

오라클 테이블 생성 시 인덱스를 생성하지 않아도 PK, Unique 컬럼 자동으로 시판생성    

인덱스는 `Range Scan`을 한다. 인덱스는 키 컬럼 순으로 정렬되어있기 때문에,
특정값을 찾다가 해당 범위를 넘어서는 값을 만나면 멈춘다.  
(테이블 풀 스캔의 경우, 테이블은 정렬되어있지 않으므로 모든 로우를 살펴봐야함)  

* 인덱스 키 컬럼은
   카디널리티가 높은 컬럼으로 지정하는 것이 좋다. 

# 인덱스 종류

## 인덱스의 종류

`B-TREE` OLTP 환경 실시간 DB 변경 ex) 주문, 회원

`BIT MAP` OLAP 환경 ex) 데이터 분석

### B-TREE 인덱스 (종류 5가지)

① UNIQUE INDEX
- KEY 값에 중복되는 데이터가 없다
- 인덱스는 이미 정렬되어 있고 생성시 오름차순, 내림 차순

② Non UNIQUE INDEX

③ Function Based INDEX (FBI)
- 인덱스는 WHERE 절에 오는 조건 컬럼이나 조인 컬럼 등에 만들어야 한다
   인덱스를 사용하려면 WHERE 절의 조건을 절대로 다른 형태로 가공하면 X

```sql
CREATE INDEX idx_prof
ON Professor (Pay + 100)
```

Professor 테이블에 Pay + 100은 없지만 인덱스를 만들 때 + 100을 해서 만듦

Pay 컬럼에 + 100 한 값을 인덱스 기준으로 !

④ DESCENDING INDEX
큰 값이 먼저 오도록 내림차순으로 인덱스 생성

⑤ Composite INDEX (결합 인덱스)
- 주로 WHERE 절의 조건 컬럼이 2개 이상으로 AND로 연결되어 쓸 때 사용
- 성능 악화 가능성이 신중하게 생성

### BITMAP INDEX

- 데이터 값의 종류가 적고 동일한 데이터가 많을 경우 사용
- 데이터의 변경량이 적어야 한다
- 컬럼 값에 따라 맵이 생성된다
∴ 데이터 변경 시
B-TREE INDEX는 관련 블록만 변경
BIT MAP INDEX는 모든 맵을 다 수정


# 인덱스 리빌드

### 인덱스 리빌드하는 이유

인덱스 생성 후 insert update delete 등 반복하다보면 성능저하
insert update delete 등이 반복되면 트리의 레벨이 점점 늘어남

### 인덱스 레벨조회

### 인덱스 리빌드

ALTER INDEX 인덱스명 REBUILD

### 성능 저하

인덱스 생성보다 쿼리문을 효율적으로 짜는 방향으로 가기!

# 인덱스 설계 전략 (친절한 SQL 튜닝 보고 추가하기)

## 인덱스 설계시 시스템 전체적인 관점에서 고려할 요소

- 쿼리 수행 빌도
- 업무상 중요도
- 클러스터링 팩터?
- 데이터량
- DML 부하 (= 기존 인덱스 개수, 초당 ML 발생랽 자주 갱신되는 컬럼 포함 여부 등)
- 저장 공간
- 인덱스 관리 비용

# 인덱스 주의사항

## DML에 취약하다

`INDEX Split`
: 인덱스의 Block 들이 하나에서 2개로 나눠지는 현상
① INSERT

② Delete
데이터가 지워져도 인덱스는 지워지지 않는다. 해당 데이터가 사용 안된다는 표시만 있음

③ Update
인덱스는 Update 의 개념 X
Update 되면 delete 발생 후 새로운 데이터의 Insert가 발생

## 타 SQL 실행에 악영향 줄 수 있음

옵티마이 저가 새로운 인덱스가 생겼을 때
그게 더 좋을 줄 알고 실행계획을 변경하면 발생

## 인덱스를 사용해야 하는 경우

- 인덱스를 적용한 컬럼이 Where 절에서 많이 사용되는 경우
- join할 때 사용하는 컬럼
- 해당 컬럼이 null 을 포함하는 경우 (색인에 null이 제외)

## 인덱스를 사용하면 안좋은 경우

- 조회결과가 적은 경우
- 검색결과가 원본테이블에 많은 비중을 차지하는 경우
- 원본 테이블의 삽입, 삭제가 빈번한 경우
