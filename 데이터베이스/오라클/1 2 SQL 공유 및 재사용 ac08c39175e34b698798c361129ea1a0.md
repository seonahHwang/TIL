# 1.2 SQL 공유 및 재사용

## 1.2.1 소프트 파싱 vs 하드 파싱

라이브러리 캐시 

: 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간

 SGA 구성요소 

SGA

: 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간 

옵티마이저가 최적화 하는 과정에 사용하는 정보

- 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
- 오브젝트 통계 : 테이블 통계, 인덱스 통계, 컬럼 통계
- 시스템 통계 : CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등
- 옵티마이저 관련 파라미터

# 1.3 데이터 저장 구조 및  I/O 메커니즘

## 1.3.1 SQL이 느린 이유

디스크 I/O 때문

I/O 란? 잠

⇒ OS 또는 I/O 서브시스템이 I/O를 처리하는 동안 프로세스는 잠을 자기 때문 

## 1.3.2 데이터베이스 저장 구조

데이터를 저장하려면 먼저 테이블 스페이스를 생성해야한다 

세그먼트 : 테이블, 인덱스처럼 데이터 저장공간이 필요한 오브젝트 

테이블, 인덱스를 생성할 때 데이터를 어떤 테이블스페이스에 저장할지를 지정한다 

여러 익스텐트로 구성된다

익스텐트 : 하나의 세그먼트에 할당 된 공간

연속된 블록들의 집합

테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로 부터

익스텐트를 추가로 할당받는다 

익스텐트 단위로 공간을 확장한다

블록 : 사용자가 입력한 레코드를 실제로 저장하는 공간 

-한 익스텐트에 담긴 블록은 모두 같은 테이블 블록이다 

-세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치할 가능성이 적다 

-익스텐트 내 블록은 서로 인접한 연속된 공간이지만, 익스텐트끼리는 연속된 공간이 아님 

파티셔닝 기법 : 

table 을 파티션이라는 작은 단위로 나눠 관리하는 기법

## 정리

블록 : 데이터를 읽고 쓰는 단위

익스텐트 : 공간을 확장하는 단위, 연속된 블록 집합

세그먼트 : 데이터 저장공간이 필요한 오브젝트(테이블,인덱스,파티션,LOB 등)

테이블스페이스 : 세그먼트를 담는 콘테이너

데이터파일 : 디스크 상의 물리적인 OS파일 

## 1.3.3 블록 단위 I/O

블록이 바로 DBMS가 데이터를 읽고 쓰는 단위 

특정 레코드를 하나를 읽고싶어도 해당 블록을 통째로 읽는다 

오라클은 기본적으로 8KB 크기의 블록을 사용하므로 1 Byte를 읽기 위해 8KB를 읽는 셈

## 1.3.4 시퀀셜 액세스 vs 랜덤액세스

테이블 또는 인덱스 블록을 액세스하는 방식2가지

### 시퀀셜 액세스

: 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식

인덱스의 경우

인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 서로 연결돼 있다.

테이블의 경우

테이블 블록 간에는 서로 논리적인 연결고리를 갖고 있지 않다.

오라클은 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 `맵`으로 관리한다

읽을 익스텐트 목록을 맵에서 얻고, 각 인스텐트의 첫번째 블록 뒤에 연속해서 저장된 블록을 순서대로 읽으면

그게 Full Table Scan 

### 랜덤 액세스

레코드 하나를 읽기 위해 한 블록씩 접근하는 방식

## 1.3.5 논리적 I/O vs 물리적 I/O

### DB 버퍼 캐시

디스크 I/O가 성능을 결정한다

자주 읽는 블록을 매번 디스크에서 읽는 것은 매우 비효율적이다 

모든 DBMS에 데이터 캐싱 메커니즘이 필수인 이유

- 라이브러리 캐시

SQL과 실행계획, DB 저장형 함수/프로시저 등을 캐싱하는 '코드 캐시'

- DB 버퍼캐시

데이터 캐시. 디스크에서 어렵게 읽은 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적인 I/O call을 줄이는데 목적이 있음 

서버 프로세스 - 버퍼 캐시 - 데이터 파일 

캐시에서 블록을 찾는 다면 I/O Call을 하지 않아도 됨

버퍼 캐시는 공유 메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 득을 본다 

### 논리적 I/O vs 물리적 I/O

논리적 블록 I/O

SQL문을 처리하는 과정에서 메모리 버퍼캐시에서 발생한 총 블록 I/O 

전기적신호

물리적 블록 I/O

디스크에서 발생한 총 블록  I/O

SQL 처리 도중 읽어야할 블록을 버퍼캐시에서 찾지 못할 때만 디스크를 액세스 하므로 논리적 블록 I/O 중 일부를 물리적으로 I/O한다 

액세스 암을 통해 물리적 작용

논리적 I/O보다 10000배 느림 

SQL 성능을 높이기 위해서 할 수 있는 일은 논리적 I/O를 줄이는 것 

어떻게? SQL을 튜닝해서 읽는 총 블록 개수를 줄인다

논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 곧 SQL 튜닝

## 1.3.6 Single Block I/O vs Multiblock I/O

메모리 캐시가 클수록 좋지만 데이터를 모두 캐시에 적재할 수는 없다

Single Block I/O 

I/O call 할 때 한번에 한 블록씩 요청해서 메모리에 적재하는 방식 

Single Block I/O 대상 오퍼레이션

- 인덱스 루트 블록을 읽을 때
- 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
- 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때

Multiblock I/O

한 번에 여러 블록씩 요청해서 메모리에 적재하는 방식 

많은 데이터 블록을 읽을 때 효율적

테이블 전체를 스캔할 때 사용 

멀티블록 I/O를 해야 양이 많을 때 I/O call 횟수를 줄일 수 있음

⇒ I/O Call 할 때 디스크 상에 그 블록과 인접한 블록(같은 익스텐트에 속한 블록)들을 한꺼번에 읽어 캐시에 미리 적재하는 기능

## 1.3.7 Table Full Scan vs Index Range Scan

Table Full Scan

시퀀셜 액세스와 Multi I/O방식 

대량을 읽어올 때 유리 

Index Range Scan

랜덤 액세스와 Single Block I/O방식

많은 데이터를 읽을 때는 Table Full Scan보다 불리

## 1.3.8 캐시 탐색 메커니즘

아래 오퍼레이션은 모두 버퍼캐시 탐색 과정을 거친다

- 인덱스 루트 블록을 읽을 때
- 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
- 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
- 테이블 블록을 Full Scan 할 때

DBMS는 버퍼캐시를 해시 구조로 관리한다

### 메모리 공유자원에 대한 액세스 직렬화

버퍼캐시는 SGA 구성요소 이므로 버퍼캐시에 캐싱된 버퍼블록은 모두 공유자원이다.

하나의 버퍼블록을 두개 이상 프로세스가 동시에 접근할 때 문제 발생

래치 : 공유자원인 버퍼캐시의 프로세스 줄 세우는 매커니즘