# 3.1 테이블 액세스 최소화

# 3.1.1 테이블 랜덤 액세스

### 인덱스 ROWID는 물리적 주소? 논리적 주소?

인덱스는 논리적 주소에 가깝다

물리적으로 직접 연결되지 않고 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있기 때문

### 메인 메모리 DB와 비교

메인 메모리 DB

인스턴스 기동하면 디스크에 저장된 데이터를 버퍼캐시로 로딩하고 인덱스 생성

이 때 인덱스는 오라클처럼 디스크상의 주소정보를 갖는게 아니라 메모리상의 주소정보 (포인터)를 갖는다.

따라서, 인덱스를 경유해서 테이블을 액세스하는 비용이 오라클과 비교할 수 없을 정도로 낮다.

오라클

테이블 블록이 수시로 버퍼캐시에서 밀려났다가 다시 캐싱되며,

그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없는 구조

메모리주소가 아닌 디스크 정보를 이용해 해시 알고리즘으로 버퍼블록을 찾아간다

### I/O 메커니즘 복습

DBA(= 데이터파일번호 + 블록번호) 는 디스크 상에서 블록을 찾기 위한 주소 정보

매번 디스크에서 블록을 읽을 수는 없음

I/O 성능을 높이려면 버퍼캐시를 활용해야한다

해싱 알고리즘으로 버퍼 헤더를 찾고 거기서 얻은 포인터로 버퍼 블록을 찾아간다

인덱스로 테이블 블록을 액세스 할 때는 

리프 블록에서 읽은 ROWID를 분해해서 DBA 정보를 얻는다

테이블 FullScan 할 때는 익스텐트 맵을 통해 읽을 블록들의 DBA 정보를 얻는다

** 인덱스 ROWID는 포인터가 아니다 

ROWID가 가리키는 테이블 블록을 버퍼캐시에서 먼저 찾아보고 못 찾을 때만 디스크에서 블록을 읽는다

### 인덱스 ROWID는 우편주소

디스크 DB가 사용하는 ROWID는 우편주소, 메인 메모리 DB가 사용하는 포인터를 전화번호에 비유 

# 3.1.2 인덱스 클러스터링 팩터

특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도

CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 매우 좋다

인덱스 ROWID로 테이블 액세스할 때,

오라클은 래치 획득과 해시 체인 스캔 과정을 거쳐 어렵게 찾아간 테이블 블록에 대한 포인터를 바로 해제하지 않고 일단 유지

⇒ 버퍼 Pinning

이 상태에서 다음 인덱스 레코드를 읽었는데, 마침 직전과 같은 테이블 블록을 가리킨다면

래치 획득, 해시 체인 스캔 과정을 생략하고 바로 테이블을 읽을 수 있다

# 3.1.3 인덱스 손익분기점

인덱스는 읽어야 할 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔하는 것보다 오히려 느려진다 

인덱스를 이용한 테이블 액세스가 Table Full Scan보다 더 느려지게 만드는 가장 핵심적인 요인 2가지

- Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식
- Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O

## 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝

대량 데이터를 빠르게 처리하려면, 인덱스와 NL 조인보다 Full Scan과 해시 조인이 유리하다 

배치 프로그램에선 파티션 활용 전략이 매우 중요한 튜닝요소

병럴 처리까지 더 할 수 있으면 금상첨화 

⇒ 인덱스는 큰 테이블에서 아주 적은 일부 데이터를 빨리 찾고자 할 때 주로 사용 

# 3.1.4 인덱스 컬럼 추가

기존 인덱스에 SAL 컬럼을 추가하는 것만으로 큰 효과를 얻을 수 있다

인덱스 스캔량은 줄지 않지만, 테이블 랜덤액세스 횟수를 줄여주기 때문이다

# 3.1.5 인덱스만 읽고 처리

테이블액세스 했을 때, 필터로 걸러지는 경우가 없다면 이는 비효율적인 것은 아님.

그런데 어떻게 성능을 높일 것인가? 

쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 액세스가 아예 발생하지 않게 하는 방법 고려 

Covered 쿼리 : 인덱스만 읽어서 처리하는 쿼리 

Covered 인덱스 : 그 쿼리에 사용한 인덱스

## include 인덱스

순전히 테이블 랜덤 액세스를 줄이는 용도로 개발됨 

오라클에는 없음

인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능 

create index emp_x01 on emp (deptno) include (sal)

⇒

SAL 컬럼을 리프 블록에만 저장

수직적 탐색에는 DEPTNO만 사용

수평적 탐색에는 SAL 컬럼도 필터 조건으로 사용할 수 있다

SAL 컬럼은 테이블 랜덤 액세스 횟수를 줄이는 용도로만 사용 

# 3.1.6 인덱스 구조 테이블

오라클에서는 IOT 라고 칭함 

테이블 블록에 있어야 할 데이터를 인덱스 리프 블록에 모두 저장하고 있는 것

일반 힙구조 테이블에는 데이터를 입력할 땐 랜덤 방식 사용 

반면 IOT는 인덱스 구조 테이블이므로 정렬 상태 유지하며 데이터 입력 

# 클러스터 테이블

## 인덱스 클러스터 테이블

클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조 

클러스터에 테이블을 담기 전에 클러스터 인덱스를 반드시 정의해야한다 

클러스터 인덱스도 B*tree 구조를 사용하지만, 테이블 레코드를 일일이 가리키지 않고 

해당 키 값을 저장하는 첫번째 데이터 블록을 가리킨다는 점이 다르다.

일반 테이블에 생성한 인덱스 레코드는 테이블 레코드와 1:1

클러스터 인덱스는 1:M관계 

클러스터 인덱스의 키값은 항상 유니크하다 

## 해시 클러스터 테이블

인덱스를 사용하지 않고, 해시 알고리즘을 사용해 클러스터를 찾아감